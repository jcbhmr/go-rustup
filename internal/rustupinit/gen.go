//go:build ignore

package main

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/fs"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/coreos/go-semver/semver"
	"github.com/jcbhmr/go-rustup/internal/robustio"
)

func findUp(filename string) (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	for {
		path := filepath.Join(dir, filename)
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}
		parentDir := filepath.Dir(dir)
		if parentDir == dir {
			return "", fs.ErrNotExist
		}
		dir = parentDir
	}
}

func version() (*semver.Version, error) {
	goModPath, err := findUp("go.mod")
	if err != nil {
		return nil, fmt.Errorf("find go.mod: %w", err)
	}
	versionPath := filepath.Clean(filepath.Join(goModPath, "../VERSION"))
	versionBytes, err := robustio.ReadFile(versionPath)
	if err != nil {
		return nil, fmt.Errorf("read VERSION: %w", err)
	}
	version := string(bytes.TrimRight(versionBytes, "\r\n"))
	return semver.NewVersion(version)
}

func downloadTool(url string, dest string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("download %s: %w", url, err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("unexpected status %d %s", resp.StatusCode, resp.Request.URL)
	}

	var destFile *os.File
	if dest == "" {
		f2, err := os.CreateTemp("", "")
		if err != nil {
			return "", fmt.Errorf("create temp dest file for download: %w", err)
		}
		dest = f2.Name()
		destFile = f2
	} else {
		f2, err := os.Create(dest)
		if err != nil {
			return "", fmt.Errorf("create dest file for download: %w", err)
		}
		destFile = f2
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, resp.Body)
	if err != nil {
		return "", fmt.Errorf("write download to dest file: %w", err)
	}
	return dest, nil
}

func gzipFile(path string) error {
	f, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("open file to gzip: %w", err)
	}
	defer f.Close()

	gzPath := path + ".gz"
	gzF, err := os.Create(gzPath)
	if err != nil {
		return fmt.Errorf("create gzipped file: %w", err)
	}
	defer gzF.Close()

	w := gzip.NewWriter(gzF)
	defer w.Close()

	_, err = io.Copy(w, f)
	if err != nil {
		return fmt.Errorf("write gzipped file: %w", err)
	}

	f.Close()
	err = os.Remove(path)
	if err != nil {
		return fmt.Errorf("remove original file: %w", err)
	}

	return nil
}

func main() {
	version, err := version()
	if err != nil {
		log.Fatal(err)
	}
	rustupVersion := &semver.Version{}
	*rustupVersion = *version
	rustupVersion.PreRelease = ""
	rustupVersion.Metadata = ""

	table := []struct {
		targetTriple string
		goos         string
		goarch       string
		abi          string
	}{
		{"aarch64-apple-darwin", "darwin", "arm64", ""},
		{"aarch64-unknown-linux-gnu", "linux", "arm64", "gnu"},
		{"i686-pc-windows-gnu", "windows", "386", "gnu"},
		{"i686-pc-windows-msvc", "windows", "386", "msvc"},
		{"i686-unknown-linux-gnu", "linux", "386", "gnu"},
		{"x86_64-apple-darwin", "darwin", "amd64", ""},
		{"x86_64-pc-windows-gnu", "windows", "amd64", "gnu"},
		{"x86_64-pc-windows-msvc", "windows", "amd64", "msvc"},
		{"x86_64-unknown-linux-gnu", "linux", "amd64", "gnu"},
	}
	for _, x := range table {
		var exeExt string
		if x.goos == "windows" {
			exeExt = ".exe"
		}
		url := fmt.Sprintf("https://static.rust-lang.org/rustup/archive/%s/%s/rustup-init%s", rustupVersion, x.targetTriple, exeExt)
		var dest string
		if x.abi == "" {
			dest = "rustup-init." + x.goos + "-" + x.goarch + exeExt
		} else {
			dest = "rustup-init." + x.goos + "-" + x.goarch + "-" + x.abi + exeExt
		}
		log.Printf("Downloading %s to %s", url, dest)
		_, err := downloadTool(url, dest)
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("Gzipping %s", dest)
		err = gzipFile(dest)
		if err != nil {
			log.Fatal(err)
		}
	}

	table2 := map[struct {
		goos   string
		goarch string
	}][]string{}
	for _, x := range table {
		key := struct {
			goos   string
			goarch string
		}{x.goos, x.goarch}
		if x.abi == "" {
			table2[key] = nil
		} else {
			table2[key] = append(table2[key], x.abi)
		}
	}
	for k, v := range table2 {
		var exeExt string
		if k.goos == "windows" {
			exeExt = ".exe"
		}
		var dest string
		if len(v) == 0 {
			dest = "rustup-init." + k.goos + "-" + k.goarch + exeExt + ".gz"
		} else if len(v) == 1 {
			dest = "rustup-init." + k.goos + "-" + k.goarch + "-" + v[0] + exeExt + ".gz"
		} else {
			log.Printf("Must create rustupinit_%s_%s.go manually", k.goos, k.goarch)
			continue
		}

		code := `// Code generated by gen.go. DO NOT EDIT.

package ` + os.Getenv("GOPACKAGE") + `

import (
	_ "embed"
	
	"github.com/jcbhmr/go-rustup/internal/ezgzip"
)

//go:embed ` + dest + `
var gzippedExecutableBytes []byte

func ExecutableBytes() []byte {
	return ezgzip.MustDecompressBytes(gzippedExecutableBytes)
}
`

		name := "rustupinit_" + k.goos + "_" + k.goarch + ".go"
		log.Printf("Writing %s", name)
		err := os.WriteFile(name, []byte(code), 0666)
		if err != nil {
			log.Fatal(err)
		}
	}
}
